<!--
 * @Author: 27
 * @LastEditors: 27
 * @Date: 2020-05-20 21:57:11
 * @LastEditTime: 2020-05-20 23:25:07
 * @FilePath: /Algorithms_Note/content/数据结构与算法基础学习/Trie字典树/Trie.md
 * @description: type some description
--> 
## 字典树Trie

> 真实案例
当时微软在一个手持设备实现通讯录的功能，当时手持设备芯片运算能力很低，
所以就出现了一个问题，当通讯录条目非常低的时候，搜索通讯录中的内容是非常慢的，
当时被一个实习生解决，解决的办法就是用了字典树

多叉树， 通讯录

#### 对比字典和Trie

如果有n个条目
字典|Trie
:-:|:-:
使用树结构查询的复杂度是O(logN)|查询每个条目的时间复杂度与字典中一共有的条目的数量无关
如果有100万个条目，2^20,logN大约需要20次|时间复杂度为O(l)，l为条目的长度

所以从这样的情况来看，这个数据结构很适合用来查字典，因为绝大多数英文单词长度都并不是很长的。

从这个场景来看，如果只是为了查英文单词的字典，每个节点可以有26个指向下个节点的指针。
但是为了更通用，其实再设计数据结构类的时候可以不用对指向下个节点的指针数量做限制。我们每个节点有若干个指向下个节点指针即可。

节点的数据结构如下：
```
class Node:
    def __init__(self):
        self.is_word = False
        self.next = {}  # {char: Node}
```
字典树图示：
![Trie字典树](./img/trie0.png)

### 实现字典树Trie
```
```
[实现Trie源代码](./my_trie.py)

